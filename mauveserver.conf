# Example mauveserver.conf file, based on Bytemark's configuration.
# Probably still needs a bit of improvement and explanation.
#

# The service which listens for alert messages
#
server {
  # persistent data store, only sqlite3 supported at the moment
  database "sqlite3:///var/lib/mauvealert/alerts.db"
  
  # you probably want to listen on all addresses
  ip "0.0.0.0"
  # UDP port number
  port 32741

  # logging options
  log_file "/var/log/mauveserver.log"
  # 0 is debug, 1 is info, 2 is warning 
  log_level 1

  # default is probably more than enough!
  #transmission_id_expire_time 600

  # few options for web interface, just the TCP port number
  web_interface {
    port 1288
  }
}


notification_method("email") {
  # email address to send from
  from "mauvealert@" + `hostname`.chomp
  # smarthost
  server "localhost"
  # add this to the subject of any emails we send
  subject_prefix "[mauve] "

  # for testing, enable this
  #deliver_to_file "/tmp/alerts.txt"  
}

# How to log into a jabber server
#
# notification_method("xmpp") {
#   jid "mauvealert@jabber.org/olympus"
#   password "WojIsEv8ScaufOm1"
# }

# How to notify by SMS - we use aql.com, you'll need to write a module
# to use any other provider.
#
# notification_method("sms") {
#   provider "AQL"
# 
#   username "x"
#   password "x"
#   from "01234567890"
#
#   # Maximum number of SMS messages to concatenate for one notification
#   max_messages_per_alert 3
# }

# Simple default notification preference for root at this machine, at all
# alert levels.  You probably want more people, see below for a more complete
# example.
# 
# Passwords are generated like so:
# ruby-1.8.7-p72 > require 'digest/sha1'                                                                                                                          
# => true                                                                                                                                                         
# ruby-1.8.7-p72 > sha1 = Digest::SHA1.hexdigest('my new super secure and easy to type on phone password')
# => "729cf161621400fa63fcb3b4750441390fbface2"
#
person("root") {
  all { email("root@localhost") }
}

# Johnny is the go-to guy for everything on this network, poor Johnny!
#
# person("johnny") {
#
#   # Johnny wants waking up 24/7 if anything urgent happens
#   urgent { sms("07111222333") }
#
#   # Email him for anything that's not urgent
#   normal { email("johnny@example.com") }
#
#   # Anything else can just be a jabber message, which he might miss.
#   # Email instead if he's unavailable/offline - but give it a try if
#   # we don't know his status.
#   low { xmpp("johnny@example.com.jabber.org", :if_presence => [:available, unknown]) || email("johnny@example.com") }
#
#   # SMS messages are expensive, if we're sending more than 5 per minute,
#   # tell the user we're going to stop until it slows down.
#   suppress_notifications_after 5 => 1.minute
#   # In general, this is too many notifications for Johnny
#   suppress_notifications_after 60 => 1.hour
# }

# Archie is Johnny's boss
#
# person("archie") {
#   all { email("archie@example.com") }
#
#   # Don't spam Archie, if more than 3 messages per hour come in.
#   suppress_notifications_after 3 => 1.hour
# }

# Here is a group of alerts generated by the core routers.  
# 
# alert_group {
#   level URGENT
#   includes { source == "core-router" }
#
#   # Johnny should get up and fix these errors very quickly, we will
#   # bother him every 15 minutes until he does.
#   # 
#   notify("johnny") { every 15.minutes }
#
#   # Archie only wants to know about these alerts if they have gone
#   # unacknowledged for a whole hour - Johnny must be slacking!  Even
#   # then he only needs to know during the working day.
#   #
#   notify("archie") { 
#     every 6.hours
#     during { unacknowledged(1.hour); hours_in_day(9..17) }
#   }
# }

# Default notification - tell root about all alerts every hour
# 
alert_group {
  level NORMAL
  notify("root") { every 1.hour }
}

